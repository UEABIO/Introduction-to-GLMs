---
title: "Introduction to Generalized Linear Models"
subtitle: "ESA and Physalia Collaboration<br><small>4th March 2024</small>"
author: "Dr Philip Leftwich"
format:
  LUstyle-revealjs:
    self-contained: true
    auto-stretch: false
    footer: "{{< fa envelope >}} [p.leftwich@uea.ac.uk](mailto: p.leftwich@uea.ac.uk) {{< fa globe >}} [philip.leftwich.github.io](https://philip.leftwich.github.io/) {{< fa brands linkedin >}} [philip-leftwich](https://www.linkedin.com/in/philip-leftwich-117052155/)"
---

# Welcome! {background-color="#D9DBDB"}

```{r}
#| include: false
#| message: false
#| warning: false

library(tidyverse)
library(MuMIn)
library(arm)
library(equatiomatic)
library(MASS)
library(pscl)
library(DHARMa)
library(lmtest)
library(fitdistrplus)
library(emmeans)

```

::: columns
::: {.column .right}


:::

::: {.column}

![](images/physalia.png){fig-align="center" fig-alt="physalia logo" width=70%}

:::
:::


## About me

::: columns
::: {.column .right}

Associate Professor in Data Science and Genetics at the [University of East Anglia](https://www.uea.ac.uk/).

<br>

Academic background in ... .

<br>

Social media at []().

:::

::: {.column}

![](images/UEA.jpg){fig-align="center" fig-alt="UEA logo" width=70%}

:::
:::

## Outline

- Why be normal? 

- GLM with binary data

- GLM with count data

## What to expect during this workshop

These workshop will run for *2 hours* each.

* Combines slides, live coding examples, and exercises for you to participate in.

* Ask questions in the chat throughout!

## What to expect during this workshop

::: columns
::: {.column}

<br>

I hope you end up with more questions than answers after this workshop!

:::

::: {.column .center-text}

<br>

![](images/great-question.gif){fig-align="center" fig-alt="Schitts Creek questions gif" width=60%}

<small>Source: <a href="https://giphy.com/gifs/schittscreek-64afibPa7ySzhFAf00">giphy.com</a></small>

:::
:::

## What you need for this workshop

* You are comfortable with simple operations in R.

* You know how to perform linear regression.

## Introduce yourselves

https://blog.slido.com/virtual-icebreakers/

## Workshop resources


## Data

> Guidotti, E., Ardia, D., (2020), “COVID-19 Data Hub”, Journal of Open Source Software 5(51):2376, doi: [10.21105/joss.02376](10.21105/joss.02376).

## Data

How to download:

```{r}
#| eval: false
#| echo: true
covid <- readr::read_csv(
  "https://raw.githubusercontent.com/nrennie/f4sg-gams/main/data/covid.csv"
  )
```

<br>

* See `data/` folder on GitHub for pre-processing.


# General linear models {background-color="#D9DBDB"}

## Recapping general linear models

OLS

## Limitations of general linear models

**Q**. What are the assumptions of a general linear model?

::: {.incremental}

* Assumes a linear relationship

* Assumes normal distribution of the residuals

* Assumes homogeneity of the residuals

:::


## Model assumptions

The equation of a linear model (lm) is given by:

$$
y_i = \beta_0 + \beta_1 x_i + \epsilon_i
$$

where:

:::{.incremental}

- $y_i$ is the predicted value of the response variable.

- $\beta_0$ is the intercept.

- $\beta_1$ is the slope coefficient, representing the change in the response variable for a one-unit change in the explanatory variable.

- $x_i$ is the value of the explanatory variable.

- $\epsilon_i$ represents the residuals of the model
:::

##

The linear regression line is the most likely line given your data if we assume each data point comes from a hypothetical bell curve centered on the regression line

![](images/prob-reg.jpeg){fig-align="center" fig-alt="probability" width=70%}

## Normal distribution

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| layout-ncol: 2
#| message: false

# Define a range of mean and standard deviations (average rate of success)
mean <- rep(c(10,20,30), 3)
sd <- rep(c(5, 7, 10), each = 3)

# Generate the data
norm_data <- map2_df(mean, sd, ~tibble(
  mean = factor(.x),
  sd = factor(.y),
  x = seq(0,40, length.out = 100),
  density = dnorm(x, .x, .y)
))  # For ordered plotting

# Plot
norm_data |> 
  filter(mean == 20) |> 
ggplot(aes(x = x, y = density, color = sd)) +
  geom_line(linewidth = 1.5) +
  scale_color_brewer(palette = "Dark2") +
  labs(title = "Change in Normal Distribution \nwith different Standard Deviations, Mean = 20",
       x = "X",
       y = "Probability",
       color = "SD") +
  theme_minimal(base_size = 14)

norm_data |> 
  filter(sd == 7) |> 
ggplot(aes(x = x, y = density, color = mean)) +
  geom_line(linewidth = 1.5) +
  scale_color_brewer(palette = "Accent") +
  labs(title = "Change in Normal Distribution \nwith different Means, SD = 7",
       x = "X",
       y = "Probability",
       color = "Mean") +
  theme_minimal(base_size = 14)

```


## Normal distribution of the residuals

When using our residuals to calculate standard error, confidence intervals and statistical signifcance these are assumed to be drawn from a normal distribution with mean zero and a constant variance. 

:::{.fragment}

This implies that the residuals, or the distances between the observed values and the values predicted by the linear model, can be modeled by drawing random values from a normal distribution.

:::

## The linear model equation

Another way to write the lm equation is:

$$
y_i \sim N(\mu = \beta_0 + \beta_1 X_i, \sigma^2)
$$
:::{.fragment}
Which literally means that $y_i$ is drawn from a normal distribution with parameters $\mu$ (which depends on $x_i$) and $\sigma$(which has the same value for all measures of $Y$).
:::


## Real data

How often do these assumptions hold true? 

good model
Count data
Challenger data? 

## Assumption testing

Residual plots? 

```{r}
#| eval: false
#| echo: true
#| message: false

car::vif(mod)
lmtest::bptest(mod)

sresid <- residuals(janka_gamma, type = "pearson")
bptest(janka_gamma, ~ sresid)


shapiro.test(residuals(model))

```

# What are Generalised linear models? {background-color="#D9DBDB"}



## Theoretical foundations


## Probability distributions and exponential families


## The link function


Let's start with linear models...

::: {.center-text}


$y_i = \beta0 + \beta_1x1 + \beta_2x2 + ... +\beta_nxn +\epsilon_i$

$\epsilon_i = \mathcal{N}(0, \sigma^2)$



:::

::: {.fragment}

<br>

Then generalised linear models...

::: {.center-text}

$\mu_i = \beta0 + \beta_1x1 + \beta_2x2 + ... +\beta_nxn$
$y_i \sim \mathcal{N}(\mu_i, \sigma^2)$

:::

:::


# A Linear Model Example {background-color="#D9DBDB"}


## Janka timber hardness

This regression analysis uses data from the Australian forestry industry recording wood density and timber hardness from 36 different samples

- Timber hardness is quantified on the "Janka" scale

- The 'amount of force required to embed a 0.444" steel ball into the wood to half of its diameter'.

## Fitting the general linear model

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false

janka <- readr::read_csv("../data/janka.csv")

```


```{r}
#| eval: true
#| echo: true
#| layout-ncol: 2
#| fig-height: 8
#| message: false

janka_ls <- lm(hardness ~ dens, data = janka)

summary(janka_ls)


janka |> 
  ggplot(aes( x = dens, y = hardness))+
  geom_point()+
  geom_smooth(method = "lm")

```


## Challenge

Open `exercises/` for prompts.

* Fit the Linear Model `lm(hardness ~ dens, data = janka)` to the janka data.

* Evaluate the model fit

```{r}
#| label: ex-lm-timer
countdown::countdown(
  minutes = 10,
  color_border = "#00AEEF",
  color_text = "#00AEEF",
  color_running_text = "white",
  color_running_background = "#00AEEF",
  color_finished_text = "#00AEEF",
  color_finished_background = "white",
  top = 0,
  margin = "1.2em",
  font_size = "2em"
)
```

. . . 

See `exercise_solutions` for full solution.

## Model diagnostics

```{r}
#| eval: true
#| echo: true
#| layout-ncol: 2
#| fig-height: 8
#| message: false

plot(janka_ls, which=2)

plot(janka_ls, which=3)
```


## Formal tests 

## Violations of assumptions

```{r}
#| eval: true
#| echo: true
#| fig-height: 8
#| message: false

library(lmtest)

# Breusch-Pagan Test of Homoscedasticity
lmtest::bptest(janka_ls)

# Shapiro-Wilk test for normality of residuals
shapiro.test(residuals(janka_ls))



```


## Challenge

Open `exercises/` for prompts.

* What can we try to improve the fit of our `lm(hardness ~ dens, data = janka)`

* Let's make suggestions then try them out

```{r}
#| label: ex-transform-lm-timer
countdown::countdown(
  minutes = 15,
  color_border = "#00AEEF",
  color_text = "#00AEEF",
  color_running_text = "white",
  color_running_background = "#00AEEF",
  color_finished_text = "#00AEEF",
  color_finished_background = "white",
  top = 0,
  margin = "1.2em",
  font_size = "2em"
)
```

. . . 

See `exercise_solutions` for full solution.


## BoxCox

## Transformations

```{r}
#| eval: true
#| echo: true
#| layout-ncol: 2
#| fig-height: 8
#| message: false

janka_sqrt <- lm(sqrt(hardness) ~ dens, data = janka)

plot(janka_sqrt, which=2)

plot(janka_sqrt, which=3)

```

## Model fit

```{r}
#| eval: true
#| echo: true
#| layout-ncol: 2
#| fig-height: 8
#| message: false

ggplot(janka, aes(x = hardness, y = dens)) +
  geom_point() +  # scatter plot of original data points
  geom_smooth(method = "lm", formula = y ~ sqrt(x)) +  # regression line
  labs(title = "Sqrt Linear Regression with ggplot2",
       x = "X", y = "Y")  # axis labels and title

```



## Residual plots

```{r}
#| eval: true
#| echo: true
#| layout-ncol: 2
#| fig-height: 8
#| message: false

janka_log <- lm(log(hardness) ~ dens, data = janka)

plot(janka_log, which=2)

plot(janka_log, which=3)

```


## Polynomials

```{r}
#| eval: true
#| echo: true
#| layout-ncol: 2
#| fig-height: 8
#| message: false

janka_poly <- lm(log(hardness) ~ poly(dens, 2), data = janka)

plot(janka_poly, which=2)

plot(janka_poly, which=3)

```

## Summary polynomial

```{r}
#| eval: true
#| echo: true
#| fig-height: 8
#| message: false


summary(janka_poly)

```

## Troublesome transformations

```{r}
#| eval: true
#| echo: true
#| layout-ncol: 2
#| fig-height: 8
#| message: false

ggplot(janka, aes(x = hardness, y = dens)) +
  geom_point() +  # scatter plot of original data points
  geom_smooth(method = "lm", formula = (y ~ log(x))) +  # regression line
  labs(title = "Log Linear Regression",
       x = "X", y = "Y")  # axis labels and title

ggplot(janka, aes(x = hardness, y = dens)) +
  geom_point() +  # scatter plot of original data points
  geom_smooth(method = "lm", formula = (y ~ poly(log(x), 2))) +  # regression line
  labs(title = "Quadratic Log Linear Regression",
       x = "X", y = "Y")  # axis labels and title



```


## Weighted least squares

weights = 1/sqrt(hardness): This argument specifies the weights to be used in the fitting process. In this case, the weights are set to be inversely proportional to the square root of hardness.

1/sqrt(hardness): This means that observations with higher values of hardness will have lower weights, and observations with lower values of hardness will have higher weights. This could be used to give more importance to certain observations in the model fitting process.
data = janka: This specifies the data frame (janka) from which the variables (sqrt(hardness) and dens) are to be taken.

Putting it all together, the code janka_wls <- lm(sqrt(hardness) ~ dens, weights = 1/sqrt(hardness), data = janka) fits a linear model where the response variable is the square root of hardness, the predictor variable is dens, and weights are inversely proportional to the square root of hardness. This is often referred to as a weighted least squares (WLS) regression model, where observations are weighted differently based on certain criteria (in this case, the square root of hardness).

```{r}
#| eval: true
#| echo: true
#| layout-ncol: 2
#| fig-height: 8
#| message: false

janka_wls <- lm(sqrt(hardness) ~ dens, weights = 1/sqrt(hardness), data = janka)

plot(janka_wls, which=2)

plot(janka_wls, which=3)

```

## 

```{r}
#| eval: true
#| echo: true
#| fig-height: 8
#| message: false

prediction_data <- data.frame(dens = sort(unique(janka$dens)))
predictions <- predict(janka_wls, newdata = prediction_data, interval = "confidence", level = 0.95)

# Adding predictions and confidence intervals to the dataframe
prediction_data$wls_pred = predictions[, "fit"]
prediction_data$wls_pred.lwr = predictions[, "lwr"]
prediction_data$wls_pred.upr = predictions[, "upr"]

ggplot(janka) +
     geom_ribbon(data = prediction_data, aes(x = dens, ymin = wls_pred.lwr, ymax = wls_pred.upr), alpha = 0.8, fill = "lightgray")+
    geom_line(data = prediction_data, aes(x = dens, y = wls_pred), color = "blue")+
  geom_point(aes(x = dens, y = sqrt(hardness)))

```

## Troublesome transformations

See screenshots

# A Generalized linear model approach

```{r}
#| eval: true
#| echo: true
#| fig-height: 8
#| message: false


janka_glm <- glm(hardness ~ dens, data = janka, family = gaussian(link = "sqrt"))

summary(janka_glm)

```


## Plot model

```{r}
#| eval: true
#| echo: true
#| fig-height: 8
#| message: false


ggplot(janka, aes(x = dens, y = hardness)) +
  geom_point() +  # scatter plot of original data points
  geom_smooth(method = "glm", method.args = list(gaussian(link = "sqrt"))) +  # regression line
  labs(title = "Linear Regression with ggplot2",
       x = "X", y = "Y")  # axis labels and title


```


## Residuals

```{r}
#| eval: true
#| echo: true
#| layout-ncol: 2
#| fig-height: 8
#| message: false

janka_glm <- glm(hardness ~ dens, data = janka, family = gaussian(link = "sqrt"))

plot(janka_glm, which=2)

plot(janka_glm, which=3)

```

## Gamma distribution

## Univariate analysis

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false

library(fitdistrplus)

descdist(janka$hardness, boot = 500)

```


##

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false

library(fitdistrplus)

par(mfrow = c(1, 2), mar = c(4, 4, 2, 1))
fg <- fitdist(sqrt(janka$hardness), "gamma")
fn <- fitdist(sqrt(janka$hardness), "norm")
plot.legend <- c("normal", "gamma")
denscomp(list(fn, fg), legendtext = plot.legend)
qqcomp(list(fn, fg), legendtext = plot.legend)
```

## 

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false

summary(fg)

summary(fn)

```

## Gamma GLM

```{r}
#| eval: true
#| echo: true
#| fig-height: 8
#| message: false


janka_gamma <- glm(hardness ~ dens, data = janka, family = Gamma(link = "sqrt"))

summary(janka_gamma)

```

## Plot model

```{r}
#| eval: true
#| echo: true
#| fig-height: 8
#| message: false


ggplot(janka, aes(x = dens, y = hardness)) +
  geom_point() +  # scatter plot of original data points
  geom_smooth(method = "glm", method.args = list(Gamma(link = "sqrt"))) +  # regression line
  labs(title = "Linear Regression with ggplot2",
       x = "X", y = "Y")  # axis labels and title


```

## Exercise

## Challenge

## Compare

```{r}
#| eval: true
#| echo: true
#| message: false



library(MuMIn)

#r.squaredLR()

# r squared

```


# Likelihood {background-color="#D9DBDB"}


## Log-Likelihood


## Maximum Likelihood

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false
#| warning: false

# Simulated data
set.seed(42)

log_likelihood_visual <- function(mean = 6, sd = 2){

data <- rnorm(100, mean = mean, sd = sd)

# Define a grid of mu and sigma values
mu_range <- seq(mean-(sd*2), mean+(sd*2), length.out = 100)
sigma_range <- seq(sd-sd, sd+sd, length.out = 100)
sigma_range[sigma_range < 1] <- 1
grid <- expand.grid(mu = mu_range, sigma = sigma_range)

# Function to calculate log-likelihood for normal distribution
log_likelihood <- function(mu, sigma, data) {
  n <- length(data)
  -n/2 * log(2 * pi) - n * log(sigma) - 1/(2 * sigma^2) * sum((data - mu)^2)
}

# Calculate log-likelihood for each combination of mu and sigma
grid$log_likelihood <- mapply(log_likelihood, mu = grid$mu, sigma = grid$sigma, MoreArgs = list(data = data))

# Plot
ggplot(grid, aes(x = mu, y = sigma, z = log_likelihood)) +
  geom_contour_filled(aes(fill = after_stat(level)), bins = 20) + # Use geom_contour_filled for filled contour plots
  labs(title = "Log-Likelihood Contour Plot",
       x = expression(mu),
       y = expression(sigma),
       fill = "Log-Likelihood") +
  theme_minimal()
}
```


## Deviance

## Pseudo R-squared

## AIC

## Likelihood ratio Test

## Challenge?

# GLMs for binary data {background-color="#D9DBDB"}

Common response variable in ecological datasets is the binary variable: we observe a phenomenon X or its “absence”

* Presence/Absence of a species

* Presence/Absence of a disease

* Success/Failure to observe behaviour

* Survival/Death of organisms

Wish to determine if $P/A∼ Variable$

Called a logistic regression or logit model

## Binary variables

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false
#| warning: false

load(file = "../data/Mayflies.rda")

```

- Investigating mayfly abundance in relation to pollution gradient measured in Cumulative Criterion Units (CCU)

- Mayflies serve as indicators of stream health due to sensitivity to metal pollution

- Higher CCU values indicate increased metal pollution, potentially impacting mayfly presence or absence in the stream

## Example

If I just fit a regular linear model to this data:

```{r}
#| eval: true
#| echo: true
#| fig-height: 8
#| layout-ncol: 2
#| message: false
#| warning: false

ggplot(Mayflies, aes(x=CCU, y=Occupancy)) + geom_point()+
  geom_smooth(method = "lm")

ggplot(Mayflies, aes(x=CCU, y=Occupancy)) + geom_point()+
  geom_smooth(method = "glm", method.args = list(binomial(link = "logit"))) +  # regression line
  labs(title = "Logit-link Binomial Regression",
       x = "X", y = "Y")  # axis labels and title

```



## Bernoulli Distribution

::::{.columns}

:::{.column}

The Bernoulli distribution models the probability of success or failure in a single trial of a binary experiment, where success occurs with probability $p$ and failure with probability ${1-p}$1

:::

:::{.column}

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false
#| warning: false

# Define probabilities
p_success <- 0.7
p_failure <- 1 - p_success

# Create data frame
df <- data.frame(
  Outcome = c("Success", "Failure"),
  Probability = c(p_success, p_failure)
)

# Plot
ggplot(df, aes(x = Outcome, y = Probability, group = Outcome)) +
  geom_bar(stat = "identity") +
  labs(title = "Probability Distribution of a Bernoulli Random Variable",
       x = "Outcome",
       y = "Probability") +
  theme_minimal()

```

:::

::::

## Probability distribution

:::: columns

::: {.column}
$logit(p) = \log \frac{p}{1 - p}$

$y_i = Bernoulli(p) = \frac{p}{1 - p}$
:::

::: {.column}
**Mean of distribution** Probability (p) of observing an outcome

**Variance of observed responses** As observed responses approach 0 or 1, the variance of the distribution decreases
:::

::::

## The link function

If $μ = xβ$ is only true for normally distributed data, 
then, if this is not the case, we must use a transformation on the expected values:

$$g(μ) = xβ$$

where $g(μ)$ is the link function.

This allows us to relax the normality assumption.

## The logit link

For binary data, the link function is called the logit:

$$ logit(p) = \log \frac{p}{1 - p} $$

where $p$ represents the expected values (probability that $Y = 1$).

To obtain the odds $(p / (1 - p))$, we log-transform them.


## The logit link

$$ logit(p) = \log \frac{p}{1 - p} $$

Get the odds $(μ / (1 - μ))$ and log-transform them.

The odds put our expected values on a 0 to +Inf scale.

The log transformation puts our expected values on a -Inf to +Inf scale.

Now, the expected values can be linearly related to the linear predictor.


## Probability, odds, logit-odds

```{r}
#| eval: true
#| echo: false
#| layout-ncol: 3
#| message: false
#| warning: false

# Generate a sequence of independent variable values
independent_variable <- seq(-10, 10, by = 0.5)

# Define a function to calculate probabilities
calculate_probability <- function(x) {
  probability <- 1 / (1 + exp(-x))
  return(probability)
}

# Define a function to calculate odds
calculate_odds <- function(probability) {
  odds <- probability / (1 - probability)
  return(odds)
}

# Define a function to calculate log odds
calculate_log_odds <- function(odds) {
  log_odds <- log(odds)
  return(log_odds)
}

# Calculate probabilities, odds, and log odds
probabilities <- sapply(independent_variable, calculate_probability)
odds <- sapply(probabilities, calculate_odds)
log_odds <- sapply(odds, calculate_log_odds)

# Plot the relationships
par(mfrow = c(1, 3), mar = c(5, 5, 2, 2))
plot(independent_variable, probabilities, type = "l", col = "blue", xlab = "Independent Variable", ylab = "Probability", main = "Change in Probability", ylim = c(0, 1))
plot(independent_variable, odds, type = "l", col = "red", xlab = "Independent Variable", ylab = "Odds", main = "Change in Odds")
plot(independent_variable, log_odds, type = "l", col = "green", xlab = "Independent Variable", ylab = "Log Odds", main = "Change in Log Odds")


```


## Example

```{r}
#| eval: true
#| echo: true
#| message: false
#| warning: false

mayfly_glm <- glm(Occupancy ~ CCU, family = binomial(link = "logit"), data = Mayflies)

summary(mayfly_glm)

```

Each coefficient corresponds to a predictor variable, indicating the change in the **log odds** of the response variable associated with a one-unit change in that predictor, holding other predictors constant.

## Interpret the model

- Interpretation of coefficients involves exponentiating them to obtain odds ratios.

- An odds ratio greater than 1 implies higher odds of the event occurring with an increase in the predictor.

- An odds ratio less than 1 implies lower odds of the event occurring with an increase in the predictor.

## Intepret the model

| Probability | Odds                              | Log Odds | Verbiage               |
|-------------|-----------------------------------|-----------------|------------------------|
| $p=.95$     | $\frac{95}{5} = \frac{19}{1} = 19$ |      2.94           | 19 to 1 odds for      |
|-------------|-----------------------------------|-----------------|------------------------|
| $p=.75$     | $\frac{75}{25} = \frac{3}{1} = 3$  |       1.09          | 3 to 1 odds for       |
|-------------|-----------------------------------|-----------------|------------------------|
| $p=.50$     | $\frac{50}{50} = \frac{1}{1} = 1$  |        0         | 1 to 1 odds           |
|-------------|-----------------------------------|-----------------|------------------------|
| $p=.25$     | $\frac{25}{75} = \frac{1}{3} = 0.33$ |    -1.11            | 3 to 1 odds against   |
|-------------|-----------------------------------|-----------------|------------------------|
| $p=.05$     | $\frac{95}{5}  = \frac{1}{19} = 0.0526$ |   -2.94          | 19 to 1 odds against  |

## Logit odds

When we use a binomial model, we produce the 'log-odds', this produces a fully unconstrained linear regression as anything less than 1, can now occupy an infinite negative value -∞ to ∞.


$$\log\left(\frac{p}{1-p}\right)	=	\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{2}$$

$$\frac{p}{1-p}	=	e^{\beta_{0}}e^{\beta_{1}x_{1}}e^{\beta_{2}x_{2}}$$

##

- We can interpret $\beta_{1}$ and $\beta_{2}$ as the increase in the log odds for every unit increase in $x_{1}$ and $x_{2}$. 

- We could alternatively interpret $\beta_{1}$ and $\beta_{2}$ using the notion that a one unit change in $x_{1}$ as a percent change of $e^{\beta_{1}}$ in the odds. 


##

For the intercept: 
- The estimate as log odds is 5.102.
- Therefore the odds are 164
- Over 99% probability of observing mayfly when CCU = 0

::: {.fragment}

For the predictor variable `CCU`:
- The estimate is -3.051.
- This means that for every one unit increase in `CCU`, the log odds of the response variable decreases by 3.051, holding all other predictors constant.

:::

:::{.fragment}
Now, let's interpret the coefficient for `CCU` using the odds ratio interpretation:
- The odds ratio associated with `CCU` is calculated as $e^{\beta_{\text{CCU}}} = e^{-3.051}$.
- Therefore, $e^{\beta_{\text{CCU}}} \approx 0.048$.
- This means that for every one unit increase in `CCU`, the odds of the response variable decrease by a multiple of 0.048
:::

## Challenge


Open `exercises/` for prompts.

* Work with the odds and probability calculators

* Check how comfortable you are with additive log-odds, multiplicative odds and changing probability

```{r}
#| label: ex-odds-timer
countdown::countdown(
  minutes = 10,
  color_border = "#00AEEF",
  color_text = "#00AEEF",
  color_running_text = "white",
  color_running_background = "#00AEEF",
  color_finished_text = "#00AEEF",
  color_finished_background = "white",
  top = 0,
  margin = "1.2em",
  font_size = "2em"
)
```

. . . 

See `exercise_solutions` for full solution.

## Model fit

For a simple Bernoulli/Binary GLM there are only a few checks that apply:

## Model fit

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| layout-ncol: 3
#| message: false

dresid <- resid(mayfly_glm, type = "deviance")
hist(dresid)

plot(mayfly_glm, which = 2)

plot(mayfly_glm, which = 4)

```

## Model fit

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false

plot(mayfly_glm, which = 1)

```


## DHARMa fit

```{r}
library(DHARMa)
plot(simulateResiduals(mayfly_glm))

```


## Prediction

```{r}

# Predictions for existing data
# predict(mayfly_glm, type = "response")

# Predictions for new data
new_CCU<- data.frame(CCU = c(0,1,2,3,4,5))
predict(mayfly_glm, newdata = new_CCU, type = "response")

```

## Emmeans

```{r}

emmeans::emmeans(mayfly_glm, 
                 specs = ~ CCU, 
                 at=list(CCU=c(0:5)), 
                 type='response') 


```

## Prediction plots with emmeans

```{r}
means <- emmeans::emmeans(mayfly_glm, 
                 specs = ~ CCU, 
                 at=list(CCU=c(0:5)), 
                 type='response') |> 
  as_tibble()

ggplot(Mayflies, aes(x=CCU, y=Occupancy)) + geom_point()+
    geom_ribbon(data = means,
              aes(x = CCU,
                  y = prob,
                  ymin = asymp.LCL,
                  ymax = asymp.UCL),
              alpha = .2)+
  geom_line(data = means,
            aes(x = CCU,
                y = prob)) +  # regression line
  labs(title = "Logit-link Binomial Regression",
       x = "X", y = "Y")  # axis labels and title

```


## Exercise

## Challenge

Open `exercises/` for prompts.

* Using the malaria dataset fit a binomial glm to look at the predictors of malaria in the Seychelles warbler

* Check the model fit

* Make predictions

* Produce a suitable figure

```{r}
#| label: ex-malaria-timer
countdown::countdown(
  minutes = 30,
  color_border = "#00AEEF",
  color_text = "#00AEEF",
  color_running_text = "white",
  color_running_background = "#00AEEF",
  color_finished_text = "#00AEEF",
  color_finished_background = "white",
  top = 0,
  margin = "1.2em",
  font_size = "2em"
)
```

. . . 

See `exercise_solutions` for full solution.


# GLMs for Binomial data {background-color="#D9DBDB"}

## Proportion data and GLM

Sometimes, count data aligns more closely with logistic regression methodologies than it initially appears.

We're not looking at typical count data when measuring the number of occurrences with a known total sample size.

Imagine, for example, we're studying the prevalence of a native underbrush species across various forest plots. We assess 15 different plots, each meticulously surveyed for the presence of this underbrush, counting the number of square meters where the underbrush is present versus absent within a standard area:

$$\frac{M^2~\text{with native underbrush (successes)}}{\text{Total surveyed area in}~M^2~(\text{trials})}$$

Bound between zero and one


## Binomial distribution

:::: columns

::: {.column}

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false

# Define a range of trials
trial_sizes <- c(5, 10, 20, 50, 100)

# Define the probability of success
p_success <- 0.7

# Generate the binomial distribution data
binom_data <- map_df(trial_sizes, ~tibble(
  trials = .x,
  success = 0:.x,
  probability = dbinom(0:.x, .x, p_success)
)) %>%
  mutate(trials = factor(trials, levels = trial_sizes)) # This ensures the plots are ordered correctly

# Plot
ggplot(binom_data, aes(x = success, y = probability, color = trials)) +
  geom_line() + # Use geom_point() if you prefer dots
  scale_color_brewer(palette = "Dark2") +
  labs(title = "Change in Binomial Distribution with Number of Trials",
       x = "Number of Successes",
       y = "Probability",
       color = "Number of Trials") +
  theme_minimal()

```

::: 


:::{.column}


$logit(p) = \log \frac{p}{1 - p}$

$y_i = Binomial(n,p)$

* It is the collection of Bernoulli trials for the same event

* It is represented by the number of Bernoulli trials $n$

* It is also the probability of an event in each trial $p$

:::

::::

##

$P(X = s) = C(n, s) \cdot p^s \cdot (1 - p)^{n - s}$

Where:

- $n$ is the total number of trials of an event.
- $s$ corresponds to the number of times an event should occur.
- $p$ is the probability that the event will occur.
- $(1 - p)$ is the probability that the event will not occur.
- $C$ term represents combinations, calculated as $C(n, s) = \frac{n!}{s!(n - s)!}$, representing the number of ways to choose $s$ successes out of $n$ trials.


## Example

TEXT

:::: columns

::: {.column}

```{r}
#| eval: true
#| echo: true
#| fig-height: 8
#| message: false

# According to the situation:
# n = 5,
# s = 5,
# p = 0.95,
# (1 — p) = 0.05

p = 1 * (0.95)^(5) * (0.05)^(0)

p

```
:::

::: {.column}

```{r}

dbinom(5, 5, 0.95)

```
:::

## Case study

## Binomial VS Bernoulli Keypoints!

Bernoulli deals with the outcome of the single trial of the event, whereas Binomial deals with the outcome of the multiple trials of the single event.

Bernoulli is used when the outcome of an event is required for only one time, whereas the Binomial is used when the outcome of an event is required multiple times.

## Exercise

## Weights

## Predictions/write-up

## Overdispersion

:::: columns

::: {.column}

**Binomial**
$P(X = s) = C(n, s) \cdot p^s \cdot (1 - p)^{n - s}$

:::

:::{.column}

**Quasibinomial**
$P(X = s) = C(n, s) \cdot p(p+k\theta)^{s-1} \cdot (1 - pk\theta)^{n - s}$

:::

::::

Where:

- $n$ is the total number of trials of an event.
- $s$ corresponds to the number of times an event should occur.
- $p$ is the probability that the event will occur.
- $(1 - p)$ is the probability that the event will not occur.
- $C$ term represents combinations, calculated as $C(n, s) = \frac{n!}{s!(n - s)!}$, representing the number of ways to choose $s$ successes out of $n$ trials.

- $\theta$ term describes additional variance outside of the Binomial distribution


## Challenge

# GLMs for count data {background-color="#D9DBDB"}

## Poisson

:::: columns

::: {.column}

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false

# Define a range of lambda values (average rate of success)
lambda_values <- c(1, 4, 10, 20, 50)

# Generate the Poisson distribution data
poisson_data <- map_df(lambda_values, ~tibble(
  lambda = .x,
  events = 0:75, # Assuming a reasonable range for visualization
  probability = dpois(0:75, .x)
)) |> 
  mutate(lambda = factor(lambda, levels = lambda_values)) # For ordered plotting

# Plot
ggplot(poisson_data, aes(x = events, y = probability, color = lambda)) +
  geom_line(linewidth = 1.5) +
  scale_color_brewer(palette = "Dark2") +
  labs(title = "Change in Poisson Distribution with Different Lambda",
       x = "Number of Events",
       y = "Probability",
       color = "Lambda") +
  theme_minimal(base_size = 14)

```

::: 

::: {.column}

Count or rate data are ubiquitous in the life sciences (e.g number of parasites per microlitre of blood, number of species counted in a particular area). These type of data are **discrete** and **non-negative**.

A useful distribution to model abundance data is the **Poisson** distribution: 

a discrete distribution with a single parameter, λ (lambda), which defines both the mean and the variance of the distribution.

:::


::::

## GLM

::: {.incremental}

Recall the simple linear regression case (i.e a GLM with a Gaussian error structure and identity link). For the sake of clarity let's consider a single explanatory variable where $\mu$ is the mean for *Y*:

$\mu_i = \beta0 + \beta_1x1 + \beta_2x2 + ... +\beta_nxn$

$y_i \sim \mathcal{N}(\mu_i, \sigma^2)$

* The mean function is **unconstrained**, i.e the value of $\beta_0 + \beta_1X$ can range from $-\infty$ to $+\infty$. 

* If we want to model count data we therefore want to **constrain** this mean to be positive only. 

* Mathematically we can do this by taking the **logarithm** of the mean (the log is the default link for the Poisson distribution). 

* We then assume our count data variance to be Poisson distributed (a discrete, non-negative distribution), to obtain our Poisson regression model (to be consistent with the statistics literature we will rename $\mu$ to $\lambda$):

:::

## GLM Poisson

![](images/poisson_regression.webp){fig-align="center" fig-alt="Poisson equation" width=100%}

## Poisson limitations

The **Poisson** distribution has the following characteristics:

::: {.incremental}

* **Discrete** variable (integer), defined on the range $0, 1, \dots, \infty$.

* A single ***rate*** parameter $\lambda$, where $\lambda > 0$.

* **Mean** = $\lambda$  

* **Variance** = $\lambda$

:::


## Poisson: Case study

:::: columns

::: {.column}

![](images/cuckoo.jpg){fig-align="center" fig-alt="Cuckoo" width=50%}
:::

:::{.column}

In a study by [Kilner *et al.* (1999)](http://www.nature.com/nature/journal/v397/n6721/abs/397667a0.html), the authors
studied the begging rate of nestlings in relation to total mass of the brood of **reed warbler chicks** and **cuckoo chicks**.
The question of interest is:

> How does nestling mass affect begging rates between the different species?

:::

::::

##

This model is inadequate. It is predicting **negative** begging calls *within* the 
range of the observed data, which clearly does not make any sense.

```{r}
#| eval: false
#| echo: true
#| fig-height: 8
#| message: false

cuckoo_lm <- lm(Beg ~ Mass + Species + Mass:Species, data = cuckoo)
```


```{r}
#| include: FALSE

cuckoo <- read_csv("../data/cuckoo.csv")

```

```{r}
#| eval: true
#| echo: false
#| fig-height: 7
#| message: false

cuckoo_lm <- lm(Beg ~ Mass + Species + Mass:Species, data = cuckoo)

broom::augment(cuckoo_lm, type.predict = "response") %>% 
ggplot(aes(x=Mass, y=.fitted, colour=Species)) + 
  geom_point() +
  geom_line()+
  geom_hline(yintercept = 0, linetype = "dashed")+
  scale_colour_manual(values=c("green3","turquoise3"))+
  scale_x_continuous(limits = c(0,40)) +
  theme_minimal()



```


## Diagnostics

Let us display the model diagnostics plots for this linear model.

```{r}
#| echo: false
#| layout-ncol: 2
#| fig-height: 8

plot(cuckoo_lm, which=2)

plot(cuckoo_lm, which=3)
```


* Curvature

* Funnelling effect


## Biological data and distributions

fitdistrplus?

## Poisson model

We should therefore try a different model structure.

The response variable in this case is a classic **count data**: **discrete** and bounded below by zero (i.e we cannot have negative counts). We will therefore try a **Poisson model** using the canonical **log** link function for the mean:


* λ varies with x (mass) which means residual variance will also vary with 
x, which means that we just relaxed the homogeneity of variance assumption!

* Predicted values will now be integers instead of fractions

* The model will never predict negative values (Poisson is strictly positive)

$$
    \log{\lambda} = \beta_0 + \beta_1 M_i + \beta_2 S_i + \beta_3 M_i S_i
$$

where $M_i$ is nestling mass and $S_i$ a **dummy** variable

$S_i = \left\{\begin{array}{ll}1 & \text{if } i \text{ is warbler},\\0 & \text{otherwise}.\end{array}\right.$

The term $M_iS_i$ is an **interaction** term. Think of this as an additional explanatory variable in our model.
Effectively it lets us have **different** slopes for different species (without an interaction term we assume that
both species have the same slope for the relationship between begging rate and mass, and only the intercept differ).

## Regression lines

The mean regression lines for the two species look like this:

::: {.incremental}

* **Cuckoo** ($S_i=0$)

* $\begin{aligned}\log{\lambda} & = \beta_0 + \beta_1 M_i + (\beta_2 \times 0)  + (\beta_3 \times M_i \times 0)\\\log{\lambda} & = \beta_0 + \beta_1 M_i\end{aligned}$
    


* **Warbler** ($S_i=1$)

* $\begin{aligned}\log{\lambda} & = \beta_0 + \beta_1 M_i + (\beta_2 \times 1)  + (\beta_3 \times M_i \times 1)\\\log{\lambda} & = \beta_0 + \beta_1 M_i + \beta_2 + \beta_3M_i\\\end{aligned}$

:::


## Fit the Poisson model

Fit the model with the interaction term in R:

```{r}
#| echo: true

cuckoo_glm1 <- glm(Beg ~ Mass + Species + Mass:Species, data=cuckoo, family=poisson(link="log"))

summary(cuckoo_glm1)
```

> Note there appears to be a negative interaction effect for Species:Mass, indicating that Begging calls do not increase with mass as much as you would expect for Warblers as compared to Cuckoos.


## Exercise 

Open `exercises/exercise_04.R` for prompts.

* Fit a Poisson model to the cuckoo data

* Look at the residual plots - how have they changed? 


```{r}
#| label: ex-pois-timer
countdown::countdown(
  minutes = 10,
  color_border = "#00AEEF",
  color_text = "#00AEEF",
  color_running_text = "white",
  color_running_background = "#00AEEF",
  color_finished_text = "#00AEEF",
  color_finished_background = "white",
  top = 0,
  margin = "1.2em",
  font_size = "2em"
)
```


## Model summary

## Parameter estimates

## Deviance

## Poisson model check

```{r}
#| echo: false
#| layout-ncol: 2
#| fig-height: 8

plot(cuckoo_glm1, which=2)

plot(cuckoo_glm1, which=3)
```

## Mean-centering

```{r}

cuckoo$mass.c <- cuckoo$Mass - mean(cuckoo$Mass, na.rm =T)

cuckoo_glm2 <- glm(Beg ~ mass.c + Species + mass.c:Species, data=cuckoo, family=poisson(link="log"))
```


## Model selection

Likelihood ratio tests, AIC - exercise/reminder?


## Exercise

Look at the effect of mean-centering on estimates

## Offset - for rates

```{r}

cuckoo_glm3 <- glm(Call_Total ~ mass.c + Species + mass.c:Species, data=cuckoo, offset = log(Mins), family=poisson(link="log"))

summary(cuckoo_glm3)

```


## Poisson limitations

So for the Poisson regression case we assume that the mean and variance are the same.
Hence, as the mean *increases*, the variance *increases* also (**heteroscedascity**).
This may or may not be a sensible assumption so watch out! Just because a Poisson distribution *usually* fits well for count data, doesn't mean that a Gaussian distribution *can't* always work.

Recall the link function between the predictors and the mean and the rules of logarithms (if $\log{\lambda} = k$(value of predictors), then $\lambda = e^k$):


## Overdispersion

When the residual deviance is higher than the residual degrees of freedom, we say that the model is overdispersed. This situation is mathematically represented as:

$$
\phi = \frac{\text{Residual deviance}}{\text{Residual degrees of freedom}}
$$

Overdispersion occurs when the variance in the data is even higher than the mean, indicating that the Poisson distribution might not be the best choice. This can be due to many reasons, such as the presence of many zeros, many very high values, or missing covariates in the model.

### Solutions

| Causes of over-dispersion | What to do about it | 
|---------|:-----|
| Model mis-specification (missing covariates or interactions)    | Add more covariates or interaction terms   |
| Too many zeros ("zero inflation")    | Use a zero-inflated model  |
| Non-independence of observations       | Use a generalised mixed model with random effects to take non-independence into account    |
| Variance is larger than the mean      | Use a quasipoisson GLM if overdispersion = 2-15. Use a negative binomial GLM if > 15-20  |

: Overdispersion statistic values > 1


## Quasi-Poisson GLM 

The systematic part and the link function remain the same

$$
    \log{\lambda} = \beta_0 + \beta_1 x_i
$$

*phi*$\phi$ is a dispersion parameter, it will not affect estimates but will affect *significance*. Standard errors are multiplied by $\sqrt\phi$ 

$$
Y_i = Poisson(\phi \lambda_i)
$$


Where:

- $Yi$ is the response variable.
- $\phi$ is the dispersion parameter, which adjusts the variance of the distribution

Confidence intervals and p-values WILL change.

## Exercise

Open `exercises/exercise_04.R` for prompts.

* Fit a quasipoisson model to the cuckoo data or update the previous one

```{r}

```

* Look at the residual plots - how have they changed? 

* Look at the SE and p-values - how have they changed

* Calculate new 95% confidence intervals

## Summary

## Deviance analysis

## F distributions

The presence of overdispersion suggested the use of the F-test for nested models. We will test if the squared term can be dropped from the model.

https://towardsdatascience.com/the-most-important-statistical-test-dee01f4d50cf


## Zero-inflation

"Zero-inflation" refers to the problem of "too many zeros". 

The dependent variable contains more zeros than would be expected under the standard statistical distribution for zero-bounded count data (Poisson or negative binomial). 

Zero-inflation is a common feature of count datasets. Large numbers of zeros can arise because

1) There was nothing there to count (**true zeros**)

2) Things were there but missed (**false zeros**)

## Zero-inflation

:::: columns

::: {.column}

| Model | Acronym/Abbr | Source of Overdispersion |
|---------|:-----|:-----|
| Zero-inflated Poisson | ZIP | Zeros |
| Negative Binomial | NegBin | Positive integers |
| Zero-inflated Negative Binomial | ZINB | Zeros + Positive integers |

:::

::: {.column}

![](images/zip.png){fig-align="center" fig-alt="Zip" width=100%}

:::

::::

## ZIP in R

In a ZIP model we define two halves of the model; the first half models the count process (**i.e. a Poisson GLM explaining non-zero integers**) and the second half models the binomial (**i.e. explains the zeros**).

```{r}
#| eval: false
#| echo: true
#| 
install.packages("pscl")
```

```{r}
#| eval: false
#| echo: true
#| 
zip1 <- zeroinf(y ~ x1 + x2 | x1 + x2,
                dist = "poisson",
                link = "logit",
                data = dataframe)
```

## Alternative model design

You can change the zero-inflation model's link function and use AIC to decide on the best model

```{r}
#| eval: false
#| echo: true

# zeros modelled with a constant
y ~ x1 + x2

# zeros modelled with the same variables
y ~ x1 + x2 | x1 + x2

# zeros modelled with different variables
y ~ x1 + x2 | z1 +z2

```


## Checking for zero-inflation


RETURN TO CUCKOO DATA! 


## Fit the model


## AIC


## Diagnostics

qqnorm(sresid)
qqline(sresid, col = "red")


## Negative Binomial

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false

##Negative Binomial Distribution (Varying Shape Parameter r)
#In the negative binomial distribution:
  
#  Shape Parameter (r): Represents the number of successes required before the experiment is stopped.
#Probability of Success (p): Represents the probability of success in each Bernoulli trial.
#As r increases:
  
#  The distribution becomes more skewed to the right.
#The average number of failures before success increases.
#The variance of the distribution also increases, indicating greater variability.

# Function to generate negative binomial distribution data
generate_nbinom_data <- function(r, p) {
  tibble(failures = 0:(10*r), 
         probability = dnbinom(0:(10*r), size = r, prob = p))
}

# Define range of shape parameter values (r)
r_values <- rep(c(2, 5, 10), times = 3)  # Number of successes

# Fixed probability of success
p_fixed <- rep(c(0.2, 0.4, 0.6), each = 3)  

# Generate negative binomial distribution data for different r values
nbinom_data <- map2_df(r_values, p_fixed, ~generate_nbinom_data(r = .x, p = .y) 
                      %>% mutate(r = as.factor(.x)) %>% mutate(p = as.factor(.y))) 

# Plot for negative binomial distribution
ggplot(nbinom_data, aes(x = failures, y = probability, color = r, group = interaction(r,p))) +
  geom_line() +
  scale_color_brewer(palette = "Dark2")+
  labs(title = "Negative Binomial Distribution with Varying Shape Parameter (r)",
       x = "Number of Failures",
       y = "Probability",
       color = "Number of Successes (r)") +
  theme_minimal()+
  facet_wrap(~p)+
  gghighlight::gghighlight()

```

## Negative Binomial

Negative binomial GLMs are favored when overdispersion is high.

It has two parameters, $μ$ and $k$. $k$ controls for the dispersion parameter (smaller $k$ indicates higher dispersion). It corresponds to a combination of two distributions (Poisson and gamma).

It assumes that the $Y_i$ are Poisson distributed with the mean $μ_i$ assumed to follow a gamma distribution:

$$
E(Y_i) = μ_i \\
\text{Var}(Y_i) = μ_i + μ_i^2/k
$$


## Fitting a negative binomial in R

Negative binomial is not in the `glm()` function

## Exercise

## Challenge

# Other distributions {background-color="#D9DBDB"}

## Gamma

:::: columns

::: {.column}

```{r}
#| eval: true
#| echo: false
#| fig-height: 8
#| message: false

# Define a range of shape values
shape_values <- c(1, 2, 5, 10)
scale_value <- 2 # Keep scale fixed for simplicity

# Generate the Gamma distribution data
gamma_data <- map_df(shape_values, ~tibble(
  shape = .x,
  x = seq(0, 20, length.out = 100),
  density = dgamma(seq(0, 20, length.out = 100), shape = .x, scale = scale_value)
)) %>%
  mutate(shape = factor(shape, levels = shape_values)) # For ordered plotting

# Plot
ggplot(gamma_data, aes(x = x, y = density, color = shape)) +
  geom_line() +
  scale_color_brewer(palette = "Dark2") +
  labs(title = "Change in Gamma Distribution with Different Shape Parameters",
       x = "Value",
       y = "Density",
       color = "Shape Parameter") +
  theme_minimal()

```

::: 

::: {.column}

Second column

:::

::::

# Simulate {background-color="#D9DBDB"}


# Survival {background-color="#D9DBDB"}

```{r}
#| eval: false
#| echo: false

model3 <- survreg((Surv(`Hours`, event) ~ source * supplementation), data = data2, dist = "weibull")
lin.pred <- predict(model3, type = "lp")[data2$event ==1]
log.resid <- log(data2$`Hours`[data2$event==1]) - lin.pred
car::qqPlot(exp(log.resid), dist = "weibull", shape = 1/model3$scale)
```

# Wrap-up {background-color="#D9DBDB"}

## Where next?


<br><br>

::: {.fragment}


* (Generalised) Linear **Mixed** Models

:::
::: {.fragment}
* Generalised Additive Models

:::


## Live demo!

<br><br>

::: {.fragment}

See `examples/example_04.R` for full code.

:::

## Exercise 4

Open `exercises/exercise_04.R` for prompts.

* Look at the ACF and PACF plots of the residuals from your previous GAM.

* Try fitting a GAMM model instead.

```{r}
#| label: ex-4-timer
countdown::countdown(
  minutes = 10,
  color_border = "#b20e10",
  color_text = "#b20e10",
  color_running_text = "white",
  color_running_background = "#b20e10",
  color_finished_text = "#b20e10",
  color_finished_background = "white",
  top = 0,
  margin = "1.2em",
  font_size = "2em"
)
```

. . . 

See `exercise_solutions/exercise_solutions_04.R` for full solution.

## Additional resources

* GLMs resource list: 

* Discovering Statistics - Andy Field

* An Introduction to Generalized Linear Models - Dobson & Barnett

* An Introduction to Statistical Learning with Applications in R - James, Witten, Hastie & Tibshirani

* Mixed Effects Models and Extensions in Ecology with R - Zuur, et al.



## 

::: columns
::: {.column}

<br>

{{< fa brands linkedin >}} [philip-leftwich](https://www.linkedin.com/in/philip-leftwich-117052155/)

{{< fa brands mastodon >}} [\@ecoevo.social\@PhilipLeftwich](https://ecoevo.social/@PhilipLeftwich)

{{< fa brands github >}} [PhilipLeftwich](https://github.com/Philip-Leftwich)

{{< fa globe >}} [philip.leftwich.github.io](https://philip.leftwich.github.io/)



:::
::: {.column}


:::
:::
